//! Icon texture atlas for the overlay
//!
//! All icons are combined into a single texture atlas to avoid
//! hitting texture limits. The atlas is organized as:
//! - Row 0: Colored icons
//! - Row 1: Gray icons (for runes that have gray variants)
//!
//! Generated by: scripts/generate_atlas.py

use hudhook::imgui::TextureId;
use hudhook::RenderContext;
use tracing::{debug, info};

use crate::core::constants::GreatRune;

// =============================================================================
// ATLAS CONSTANTS
// =============================================================================

pub const ATLAS_WIDTH: u32 = 1152;
pub const ATLAS_HEIGHT: u32 = 256;
pub const ICON_SIZE: u32 = 128;
pub const _ICONS_PER_ROW: u32 = 9;

// Icon indices (column in the atlas)
pub const ICON_GODRICK: u32 = 0;
pub const ICON_UNBORN: u32 = 1;
pub const ICON_RYKARD: u32 = 2;
pub const ICON_RADAHN: u32 = 3;
pub const ICON_MORGOTT: u32 = 4;
pub const ICON_MOHG: u32 = 5;
pub const ICON_MALENIA: u32 = 6;
pub const ICON_KINDLING: u32 = 7;
pub const ICON_DEATH: u32 = 8;

// =============================================================================
// EMBEDDED ATLAS
// =============================================================================

const ATLAS_PNG: &[u8] = include_bytes!("../../assets/icons_atlas.png");

// =============================================================================
// ICON ATLAS
// =============================================================================

/// Single texture atlas containing all icons
pub struct IconAtlas {
    texture_id: TextureId,
}

impl IconAtlas {
    /// Load the icon atlas texture
    pub fn load(render_context: &mut dyn RenderContext) -> Result<Self, String> {
        info!("Loading icon atlas texture");

        let texture_id = decode_and_load(render_context, ATLAS_PNG)?;

        Ok(Self { texture_id })
    }

    /// Get the texture ID for the atlas
    pub fn texture_id(&self) -> TextureId {
        self.texture_id
    }

    /// Get UV coordinates for a rune icon
    ///
    /// Returns (uv0, uv1) where uv0 is top-left and uv1 is bottom-right
    pub fn get_rune_uvs(&self, rune: GreatRune, possessed: bool) -> ([f32; 2], [f32; 2]) {
        let col = match rune {
            GreatRune::Godrick => ICON_GODRICK,
            GreatRune::Unborn => ICON_UNBORN,
            GreatRune::Rykard => ICON_RYKARD,
            GreatRune::Radahn => ICON_RADAHN,
            GreatRune::Morgott => ICON_MORGOTT,
            GreatRune::Mohg => ICON_MOHG,
            GreatRune::Malenia => ICON_MALENIA,
        };
        let row = if possessed { 0 } else { 1 };
        Self::calculate_uvs(col, row)
    }

    /// Get UV coordinates for the kindling icon
    pub fn get_kindling_uvs(&self) -> ([f32; 2], [f32; 2]) {
        Self::calculate_uvs(ICON_KINDLING, 0)
    }

    /// Get UV coordinates for the death icon
    pub fn get_death_uvs(&self) -> ([f32; 2], [f32; 2]) {
        Self::calculate_uvs(ICON_DEATH, 0)
    }

    /// Calculate UV coordinates for a given column and row
    fn calculate_uvs(col: u32, row: u32) -> ([f32; 2], [f32; 2]) {
        let u0 = (col * ICON_SIZE) as f32 / ATLAS_WIDTH as f32;
        let v0 = (row * ICON_SIZE) as f32 / ATLAS_HEIGHT as f32;
        let u1 = ((col + 1) * ICON_SIZE) as f32 / ATLAS_WIDTH as f32;
        let v1 = ((row + 1) * ICON_SIZE) as f32 / ATLAS_HEIGHT as f32;
        ([u0, v0], [u1, v1])
    }

    /// Get all runes in display order
    pub fn runes_in_order() -> [GreatRune; 7] {
        [
            GreatRune::Godrick,
            GreatRune::Unborn,
            GreatRune::Rykard,
            GreatRune::Radahn,
            GreatRune::Morgott,
            GreatRune::Mohg,
            GreatRune::Malenia,
        ]
    }
}

// =============================================================================
// PNG DECODING
// =============================================================================

/// Decode PNG bytes to RGBA and load as texture
fn decode_and_load(
    render_context: &mut dyn RenderContext,
    png_bytes: &[u8],
) -> Result<TextureId, String> {
    use image::ImageReader;
    use std::io::Cursor;

    let img = ImageReader::new(Cursor::new(png_bytes))
        .with_guessed_format()
        .map_err(|e| format!("Failed to guess format: {}", e))?
        .decode()
        .map_err(|e| format!("Failed to decode PNG: {}", e))?;

    let rgba = img.to_rgba8();
    let (width, height) = rgba.dimensions();
    let raw_data = rgba.into_raw();

    debug!(width, height, bytes = raw_data.len(), "Decoded atlas PNG");

    let texture_id = render_context
        .load_texture(&raw_data, width, height)
        .map_err(|e| format!("Failed to load texture: {:?}", e))?;

    Ok(texture_id)
}
